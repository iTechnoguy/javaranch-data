[
    {
        "answers": [
            {
                "answer": "false"
            },
            {
                "answer": "true",
                "correct": "true"
            }
        ],
        "explanation": "No keywords in Java start with a capital letter.",
        "id": "1",
        "question": "All Java keywords are written in lower case."
    },
    {
        "answers": [
            {
                "answer": "true"
            },
            {
                "answer": "false",
                "correct": "true"
            }
        ],
        "explanation": "Method and variable names can't start with a number, although they can contain numbers. myMethod2() is legal; 2myMethod() is not.",
        "id": "2",
        "question": "A method name can start with a number."
    },
    {
        "answers": [
            {
                "answer": "false"
            },
            {
                "answer": "true",
                "correct": "true"
            }
        ],
        "explanation": "Methods and variables can start with a $ character, but its not recommended.",
        "id": "3",
        "question": "A variable name can start with $."
    },
    {
        "answers": [
            {
                "answer": "true, false, 1,0"
            },
            {
                "answer": "TRUE, FALSE"
            },
            {
                "answer": "TRUE, FALSE, true, false"
            },
            {
                "answer": "1,0"
            },
            {
                "answer": "true, false",
                "correct": "true"
            }
        ],
        "explanation": "Unlike C/C++, booleans in Java are represented with the literals true and false. You can't substitute integers such as 1 and 0 where a boolean value is expected.",
        "id": "4",
        "question": "Which of these are legal values for a boolean?"
    },
    {
        "answers": [
            {
                "answer": "float"
            },
            {
                "answer": "Double"
            },
            {
                "answer": "Float"
            },
            {
                "answer": "double",
                "correct": "true"
            }
        ],
        "explanation": "Floating point literals (example: 2.27) in Java are automatically typed as doubles unless you add an \"f\" (example: 2.27f).",
        "id": "7",
        "question": "A floating point literal in Java is treated as a:"
    },
    {
        "answers": [
            {
                "answer": "false"
            },
            {
                "answer": "true",
                "correct": "true"
            }
        ],
        "explanation": "An array is an object, and Java always passes a copy of the reference to the original object. Both references now point to the same array object.",
        "id": "8",
        "question": "When you pass a reference to an array as an argument to a method call, you pass a new reference to the original array."
    },
    {
        "answers": [
            {
                "answer": "Yes always"
            },
            {
                "answer": "Not always",
                "correct": "true"
            }
        ],
        "explanation": "Think of a call to System.gc( ) as a... suggestion. Garbage collection may or may not actually occur.",
        "id": "9",
        "question": "Does a call to System.gc() force garbage collection to take place? (assuming there are objects to be collected)"
    },
    {
        "answers": [
            {
                "answer": "true"
            },
            {
                "answer": "false",
                "correct": "true"
            }
        ],
        "explanation": "This test asks if the expression (y is greater than 2) is NOT true... and that's false. y IS greater than 2, so the result is false.",
        "id": "11",
        "question": "Assume x=2 and y=4. What is the result of (!(y>x))"
    },
    {
        "answers": [
            {
                "answer": "false"
            },
            {
                "answer": "true",
                "correct": "true"
            }
        ],
        "explanation": "The test asks if the primitive values of y and x are NOT equal in value, which is true.",
        "id": "12",
        "question": "Assume x=6 and y=7. What is the result of (!(y==x))"
    },
    {
        "answers": [
            {
                "answer": "c == 5"
            },
            {
                "answer": "runtime exception "
            },
            {
                "answer": "c = 3 "
            },
            {
                "answer": "compiler error",
                "correct": "true"
            }
        ],
        "explanation": "The result of arithmetic is always at LEAST an int, so the compiler will ask for an explicit cast: byte c = (byte) a + b; even though a and b are bytes.",
        "id": "13",
        "question": "Assume: byte a=3; byte b=2; What is the result of: byte c=a+b;"
    },
    {
        "answers": [
            {
                "answer": "Yes"
            },
            {
                "answer": "No",
                "correct": "true"
            }
        ],
        "explanation": "Not in Java. A boolean has a value of true or false, not 1 and 0, or 0 and anything else. You just can't do it (watch out C folks)",
        "id": "14",
        "question": "Can you compare a boolean to an integer?"
    },
    {
        "answers": [
            {
                "answer": "a method in Object"
            },
            {
                "answer": "an operator",
                "correct": "true"
            }
        ],
        "explanation": "The \"instanceof\" operator -- if ( A instanceof B) -- tests if an object A is either an instance of B, an instance of a subclass of B, or implements the B interface.",
        "id": "15",
        "question": "What is \"instanceof\" ?"
    },
    {
        "answers": [
            {
                "answer": "true"
            },
            {
                "answer": "compiler error"
            },
            {
                "answer": "runtime exception"
            },
            {
                "answer": "false",
                "correct": "true"
            }
        ],
        "explanation": "The == operator looks ONLY for a match of bits. For two different objects, the only way == can be true is if both reference variables point to the SAME object.",
        "id": "16",
        "question": "Integer a = new Integer(5); Integer b = new Integer(5); What is the result of running: if (a==b)"
    },
    {
        "answers": [
            {
                "answer": "Yes"
            },
            {
                "answer": "No",
                "correct": "true"
            }
        ],
        "explanation": "If a class was private... who could use it? For a normal, top-level class, the only access modifiers that make sense are public and default (package). Only nested inner classes can be private.",
        "id": "17",
        "question": "Can a top-level class be marked as private?"
    },
    {
        "answers": [
            {
                "answer": "Yes"
            },
            {
                "answer": "No",
                "correct": "true"
            }
        ],
        "explanation": "A top-level class can ONLY be marked public or default (package). The protected access is just for member variables and methods, and allows subclasses outside the superclass package to inherit the protected members. ",
        "id": "18",
        "question": "Can a top-level class be marked as protected?"
    },
    {
        "answers": [
            {
                "answer": "false"
            },
            {
                "answer": "true",
                "correct": "true"
            }
        ],
        "explanation": "Protected members (methods and data) can be inherited by subclasses, including those outside the package. The only difference between default (no modifier) and protected, is that protected extends visibility outside the package... but ONLY to subclasses.",
        "id": "19",
        "question": "Methods which are marked protected can be called on any subclass of the class in which the method is declared."
    },
    {
        "answers": [
            {
                "answer": "No"
            },
            {
                "answer": "Yes",
                "correct": "true"
            }
        ],
        "explanation": "Trick question! Private methods can NOT be overriden, but they CAN be re-declared/redefined in the subclass, and called directly on the subclass object. But polymorphism will not apply.",
        "id": "20",
        "question": "Can a private method of a superclass be declared within a subclass?"
    },
    {
        "answers": [
            {
                "answer": "No"
            },
            {
                "answer": "Yes",
                "correct": "true"
            }
        ],
        "explanation": "Unlike interfaces, abstract classes CAN provide implementations of methods.",
        "id": "21",
        "question": "Can an abstract class have non-abstract methods?"
    },
    {
        "answers": [
            {
                "answer": "Yes"
            },
            {
                "answer": "No",
                "correct": "true"
            }
        ],
        "explanation": "Even a single abstract method tells the compiler that the whole class MUST be declared abstract.",
        "id": "22",
        "question": "Can a non-abstract class have abstract methods?"
    },
    {
        "answers": [
            {
                "answer": "No"
            },
            {
                "answer": "Yes",
                "correct": "true"
            }
        ],
        "explanation": "Any concrete (non-abstract) class MUST provide bodies (implementations) for the abstract methods it inherits. Otherwise, the compiler will insist that the new subclass itself be marked as abstract.",
        "id": "23",
        "question": "If a non-abstract class X inherits abstract methods from its abstract parent class Y, is the X class required to implement the inherited abstract methods?"
    },
    {
        "answers": [
            {
                "answer": "Under ALL circumstances"
            },
            {
                "answer": "Unless A is abstract",
                "correct": "true"
            }
        ],
        "explanation": "If a class is abstract, and it implements an interface, it can leave the interface implementations up to a concrete (non-abstract) subclass.",
        "id": "24",
        "question": "If a class declares that it implements an interface (class A implements B), must class A implement the methods of interface B?"
    },
    {
        "answers": [
            {
                "answer": "true"
            },
            {
                "answer": "false",
                "correct": "true"
            }
        ],
        "explanation": "The result of an arithmetic operation on any two primitive integer operands will be at least an int -- even if the operands are byte and short. ",
        "id": "25",
        "question": "TRUE or FALSE - during arithmetic, when the operands are of different types, the resulting type is ALWAYS the widest of the two types."
    },
    {
        "answers": [
            {
                "answer": "Yes"
            },
            {
                "answer": "No",
                "correct": "true"
            }
        ],
        "explanation": "You can never have a reference type of a subclass refer to an actual instance of the superclass. Because an object of type X (the superclass) wouldn't have the new methods that an object of type Y (the subclass) is supposed to have.",
        "id": "26",
        "question": "Class Y is a subclass of class X. Will this compile? Y myY = new X( );"
    },
    {
        "answers": [
            {
                "answer": "No"
            },
            {
                "answer": "Yes",
                "correct": "true"
            }
        ],
        "explanation": "A reference variable can always refer to any object which is a subclass of the reference type, since the instance methods of the reference variable type (X) are guaranteed to be callable on the actual subclass object (class Y).",
        "id": "27",
        "question": "Class Y is a subclass of class X. Will this compile? X myX = new Y( );"
    },
    {
        "answers": [
            {
                "answer": "No"
            },
            {
                "answer": "Yes",
                "correct": "true"
            }
        ],
        "explanation": "If you do not use curly braces for an if block, then only the first statement following the if ( ) will run if the if condition is true.",
        "id": "28",
        "question": "Can you compile an if construct without using curly braces?"
    },
    {
        "answers": [
            {
                "answer": "boolean test"
            },
            {
                "answer": "iteration expression"
            },
            {
                "answer": "init statement",
                "correct": "true"
            }
        ],
        "explanation": "The init statement must be the first part of the for declaration -- example: for (int i = 7;;)",
        "id": "29",
        "question": "What goes in the first part of a for loop?"
    },
    {
        "answers": [
            {
                "answer": "Yes"
            },
            {
                "answer": "No",
                "correct": "true"
            }
        ],
        "explanation": "You can declare or initialize more than one variable in a for loop, but you can't mix declarations with initializations.",
        "id": "30",
        "question": "Is this legal? int i; for (i = 4, int t = 6;i < 0; i++)"
    },
    {
        "answers": [
            {
                "answer": "true"
            },
            {
                "answer": "false",
                "correct": "true"
            }
        ],
        "explanation": "Continue really means \"continue with the next iteration\", so execution of the current iteration stops, and execution continues at the next iteration.",
        "id": "31",
        "question": "In a for loop, the continue statement will cause execution to jump out of the loop and continue on at the first statement below the loop."
    },
    {
        "answers": [
            {
                "answer": "true"
            },
            {
                "answer": "false",
                "correct": "true"
            }
        ],
        "explanation": "An inner class can be defined inside a method, or even inside a parameter to a method! (with anonymous inner classes)",
        "id": "32",
        "question": "An inner class must be defined within the opening and closing braces of a class, but outside any method -- just like data members."
    },
    {
        "answers": [
            {
                "answer": "static"
            },
            {
                "answer": "illegal"
            },
            {
                "answer": "anonymous",
                "correct": "true"
            }
        ],
        "explanation": "A class defined within a method parameter (typically used with event listener classes) is considered anonymous. The object is created and alive, but the new class type has no name, so you can't create more instances of it except by going through that same method.",
        "id": "33",
        "question": "A class defined within a parameter to a method is:"
    },
    {
        "answers": [
            {
                "answer": "false"
            },
            {
                "answer": "true",
                "correct": "true"
            }
        ],
        "explanation": "Remember the rule: the parents must exist before the children, and this goes all the way up the ancestral tree.",
        "id": "34",
        "question": "When an object is created using new (), its constructor will not complete until all constructors higher on the inheritance tree have completed."
    },
    {
        "answers": [
            {
                "answer": "true"
            },
            {
                "answer": "false",
                "correct": "true"
            }
        ],
        "explanation": "The compiler will ONLY insert a default constructor if you don't provide any constructor at all.",
        "id": "35",
        "question": "The compiler will always insert a default, no-argument constructor into any class definition."
    },
    {
        "answers": [
            {
                "answer": "true"
            },
            {
                "answer": "false",
                "correct": "true"
            }
        ],
        "explanation": "This rule only applies to \"checked\" exceptions -- the exceptions which are subclasses of Exception but not subclasses of RuntimeException.",
        "id": "36",
        "question": "When you override a method, the overriding method in the subclass must not declare ANY new exceptions not declared by the overridden method."
    },
    {
        "answers": [
            {
                "answer": "No"
            },
            {
                "answer": "Yes",
                "correct": "true"
            }
        ],
        "explanation": "Without the 'f\", Java will consider a floating point number to be a double, and the compiler will force you to do an explicit cast.",
        "id": "37",
        "question": "Will this compile? float f = 27.24f;"
    },
    {
        "answers": [
            {
                "answer": "a float"
            },
            {
                "answer": "a double",
                "correct": "true"
            }
        ],
        "explanation": "All floating point literals are assumed to be doubles, not floats!",
        "id": "38",
        "question": "As a literal, what is 27.24?"
    },
    {
        "answers": [
            {
                "answer": "Yes"
            },
            {
                "answer": "No",
                "correct": "true"
            }
        ],
        "explanation": "In Java you must create the array using: int[]x = new int[27] or by explicitly filling in the values: int[ ]={4,2,7,3,9,8};",
        "id": "39",
        "question": "Will this compile? int[ ]x=[27];"
    },
    {
        "answers": [
            {
                "answer": "No"
            },
            {
                "answer": "Yes",
                "correct": "true"
            }
        ],
        "explanation": "All array elements are ALWAYS given default values, whether the array is a class, instance, or local variable. Primitives initialize to zero, booleans to false, chars to '\u0000' and object references to null.",
        "id": "40",
        "question": "When an array is constructed, are its elements automatically initialized?"
    },
    {
        "answers": [
            {
                "answer": "No"
            },
            {
                "answer": "Yes",
                "correct": "true"
            }
        ],
        "explanation": "This instantiation/initialization is allowed as a shortcut to creating a new array and assigning a value for each index.",
        "id": "41",
        "question": "Is this legal? int x[ ] = {2,7,4,9};"
    },
    {
        "answers": [
            {
                "answer": "No"
            },
            {
                "answer": "Yes",
                "correct": "true"
            }
        ],
        "explanation": "You can call the command-line argument variable whatever you like! And you can put the brackets [] before or after the variable name.",
        "id": "42",
        "question": "Is this legal? public static void main (String [ ] fred) "
    },
    {
        "answers": [
            {
                "answer": "4"
            },
            {
                "answer": "7"
            },
            {
                "answer": "3",
                "correct": "true"
            }
        ],
        "explanation": "X gets the value of y, THEN y is incremented. The result would have been 4 if the expression was: x = ++y;",
        "id": "43",
        "question": "Assume x=0 and y=3. What is the value of x after: x=y++;"
    },
    {
        "answers": [
            {
                "answer": "x < y"
            },
            {
                "answer": "x == y"
            },
            {
                "answer": "x > y",
                "correct": "true"
            }
        ],
        "explanation": "Y is assigned to x and THEN y is decremented",
        "id": "44",
        "question": "Given x=y--; Which of these will be true AFTER execution?"
    },
    {
        "answers": [
            {
                "answer": "Compiler error"
            },
            {
                "answer": "Compiles and runs"
            },
            {
                "answer": "Runtime exception",
                "correct": "true"
            }
        ],
        "explanation": "At runtime you will get an ArithmeticException which is not checked for at compile time. Floats and doubles will NOT throw an exception if divided by 0.",
        "id": "47",
        "question": "What happens when you divide an integer by a variable with a value of 0?"
    },
    {
        "answers": [
            {
                "answer": "Compiler error"
            },
            {
                "answer": "Compiles and runs"
            },
            {
                "answer": "Runtime exception",
                "correct": "true"
            }
        ],
        "explanation": "The modulo operator (%) is performing a divide, so you get a divide-by-zero ArithmeticException at runtime. Even using a literal 0 (y = 4%0;) instead of a variable would not cause a compiler error.",
        "id": "48",
        "question": "What happens when you put this expression in your code: int x=0; int y=4%x;"
    },
    {
        "answers": [
            {
                "answer": "Runtime exception"
            },
            {
                "answer": "Compiler error"
            },
            {
                "answer": "Compiles and runs",
                "correct": "true"
            }
        ],
        "explanation": "Floating point numbers don't produce a divide-by-zero ArithmeticException. They will give a result which is a Not a Number value.",
        "id": "49",
        "question": "What happens when you have this in your code: double x; x=24.0/0;"
    },
    {
        "answers": [
            {
                "answer": "Must explicitly cast"
            },
            {
                "answer": "Compiler error"
            },
            {
                "answer": "Smaller type is promoted",
                "correct": "true"
            }
        ],
        "explanation": "Java promotes the smaller type to the wider of the types being compared. So when comparing a byte to an int, the byte is first promoted to an int.",
        "id": "51",
        "question": "What happens when you compare two primitives of different numerical types?"
    },
    {
        "answers": [
            {
                "answer": "true"
            },
            {
                "answer": "false",
                "correct": "true"
            }
        ],
        "explanation": "\"&&\" is the short-circuit AND operator. If both values are true, the result is true, but Java won't bother to check the second condition if the first one is false.",
        "id": "53",
        "question": "x=false; y=true; What is the result of x&&y?"
    },
    {
        "answers": [
            {
                "answer": "Yes"
            },
            {
                "answer": "No",
                "correct": "true"
            }
        ],
        "explanation": "Methods CAN have more than one modifier, but not more than one ACCESS modifier. Access modifiers are public, protected, private (and of course, default/package). Early versions of the JDK allowed a private protected access, but current versions prohibit this.",
        "id": "54",
        "question": "Can a method have more than one access modifier?"
    },
    {
        "answers": [
            {
                "answer": "Yes"
            },
            {
                "answer": "No",
                "correct": "true"
            }
        ],
        "explanation": "Private means \"private to the class\". Period. Kids (subclasses) get no special treatment.",
        "id": "55",
        "question": "Can a subclass access the private member variables of its own superclass?"
    },
    {
        "answers": [
            {
                "answer": "No"
            },
            {
                "answer": "Yes",
                "correct": "true"
            }
        ],
        "explanation": "Overriden methods are allowed to have LESS restriction, and since protected is less restricted than default (package), this is allowed.",
        "id": "56",
        "question": "Can a method with no access modifier be overriden by a method marked protected?"
    },
    {
        "answers": [
            {
                "answer": "Yes"
            },
            {
                "answer": "No",
                "correct": "true"
            }
        ],
        "explanation": "Although early versions of the JDK enforced this, current versions let you initialize a final variable in the constructor, but no later. ",
        "id": "57",
        "question": "Does a final member variable have to be initialized at the time it's declared?"
    },
    {
        "answers": [
            {
                "answer": "No"
            },
            {
                "answer": "Yes",
                "correct": "true"
            }
        ],
        "explanation": "An reference variable marked final does NOT mean that the object itself can not be changed... final means that the reference can never be changed to point to some other object.",
        "id": "58",
        "question": "If a final variable is a reference to an object, can that object's data members be modified while the program is running?"
    },
    {
        "answers": [
            {
                "answer": "Yes"
            },
            {
                "answer": "No",
                "correct": "true"
            }
        ],
        "explanation": "Final methods can't be overriden... they're FINAL! The compiler will catch you.",
        "id": "59",
        "question": "Can a final method be overriden?"
    },
    {
        "answers": [
            {
                "answer": "Yes"
            },
            {
                "answer": "No",
                "correct": "true"
            }
        ],
        "explanation": "A long has 64 bits while an int has 32. You can't implicitly squish a *potentially* big thing into a little thing. The compiler doesn't care if the long variable is holding a tiny value. It just looks for the possibility of trouble.",
        "id": "60",
        "question": "Can you automatically convert a long to an int if the long value is small enough to fit into an int?"
    },
    {
        "answers": [
            {
                "answer": "Yes"
            },
            {
                "answer": "No",
                "correct": "true"
            }
        ],
        "explanation": "They're the same bit-depth, but since chars are unsigned, they might have a higher positive value than a short can accept.",
        "id": "61",
        "question": "Can you automatically/implicitly convert a char to a short?"
    },
    {
        "answers": [
            {
                "answer": "No"
            },
            {
                "answer": "Yes",
                "correct": "true"
            }
        ],
        "explanation": "Since a short will definitely fit into an int, the short is implicitly promoted. No cast needed.",
        "id": "62",
        "question": "Can you pass a short into a method call when an int is expected?"
    },
    {
        "answers": [
            {
                "answer": "nothing prints"
            },
            {
                "answer": "\"yes\" prints",
                "correct": "true"
            }
        ],
        "explanation": "\"Yes\" prints because the expression (b = true) uses the assignment operator =, not the equality operator ==. So b is set to true, and the result is true so the if condition runs the code.",
        "id": "63",
        "question": "Given this code, what prints? boolean b = false; if (b = true) {System.out.println(\"yes\");}"
    },
    {
        "answers": [
            {
                "answer": "Nothing"
            },
            {
                "answer": "First statement after while ( )",
                "correct": "true"
            }
        ],
        "explanation": "If there are no curly braces to set off a loop block, then just the first statement is executed as part of the condition and any statements following that are executed no matter what.",
        "id": "64",
        "question": "If you do not use curly braces for a while loop body, what will execute if the while condition is true?"
    },
    {
        "answers": [
            {
                "answer": "true"
            },
            {
                "answer": "false",
                "correct": "true"
            }
        ],
        "explanation": "The break statements means \"break out of this structure completely!\". So the current iteration and any other remaining iterations of the loop will not run. Execution moves to the first statement below the loop.",
        "id": "65",
        "question": "Using a break in a for loop causes the loop to break out of the current iteration and jump to the next iteration of the loop."
    },
    {
        "answers": [
            {
                "answer": "false"
            },
            {
                "answer": "true",
                "correct": "true"
            }
        ],
        "explanation": "If there is no catch(ExceptionArgument) which matches the thrown exception, then an argument which is a superclass of the exception will catch it.",
        "id": "66",
        "question": "An exception can be caught by a catch block with an argument type that is a superclass of the thrown exception."
    },
    {
        "answers": [
            {
                "answer": "true"
            },
            {
                "answer": "false",
                "correct": "true"
            }
        ],
        "explanation": "Its perfectly legal to catch the exception but do nothing about it.",
        "id": "67",
        "question": "In a try/catch, an exception will not be considered caught if the catch(Exception) block has no code within the braces { }"
    },
    {
        "answers": [
            {
                "answer": "false"
            },
            {
                "answer": "true",
                "correct": "true"
            }
        ],
        "explanation": "The finally block will always run if an exception is thrown, and then the exception is immediately passed to the calling method.",
        "id": "68",
        "question": "If an exception is not caught, the finally block will run and the rest of the method is skipped."
    },
    {
        "answers": [
            {
                "answer": "Return type"
            },
            {
                "answer": "Return type AND arg list"
            },
            {
                "answer": "Argument list",
                "correct": "true"
            }
        ],
        "explanation": "An overloaded method must change the argument list, but the return type is optional.",
        "id": "69",
        "question": "An overloaded method MUST change:"
    },
    {
        "answers": [
            {
                "answer": "false"
            },
            {
                "answer": "true",
                "correct": "true"
            }
        ],
        "explanation": "As long as the argument list is different, the overloaded method is also free to change both the return type and the access visibility.",
        "id": "70",
        "question": "Overloaded methods are free to change the access modifier."
    },
    {
        "answers": [
            {
                "answer": "true"
            },
            {
                "answer": "false",
                "correct": "true"
            }
        ],
        "explanation": "Constructors can be overloaded to allow the calling code to provide more (or less) information when the object is created.",
        "id": "71",
        "question": "Constructors can not be overloaded."
    },
    {
        "answers": [
            {
                "answer": "false"
            },
            {
                "answer": "true",
                "correct": "true"
            }
        ],
        "explanation": "Inner classes have a special relationship with the their outer (enclosing) classes, including access to private data of the outer class. For event listeners implemented as inner classes, this means you do NOT have to pass a reference to the outer class in to the constructor of the inner class. The inner class has something like an \"outer this\" (\"outer this\" is not a keyword, just the way inner classes behave).",
        "id": "72",
        "question": "An inner class has free access to private member data of the outer classes."
    },
    {
        "answers": [
            {
                "answer": "false"
            },
            {
                "answer": "true",
                "correct": "true"
            }
        ],
        "explanation": "Member variables are always given a default value -- numerical primitives get zero, chars get '\u0000', and object references get null.",
        "id": "73",
        "question": "Member (instance) variables are always assigned a default value if not explicitly initialized."
    },
    {
        "answers": [
            {
                "answer": "true"
            },
            {
                "answer": "false",
                "correct": "true"
            }
        ],
        "explanation": "You don't have to initialize a local variable, but as soon as you try to use it, you will get a compiler error because local variables aren't given default values.",
        "id": "74",
        "question": "Automatic (local) variables are always assigned a default value if not explicitly initialized."
    },
    {
        "answers": [
            {
                "answer": "the actual value"
            },
            {
                "answer": "a copy of the value",
                "correct": "true"
            }
        ],
        "explanation": "You always get a copy of whatever is in the variable -- either a primitive or a reference. So for objects, you get a copy of the reference.",
        "id": "75",
        "question": "When you pass a variable as an argument to a method call, what are you passing?"
    },
    {
        "answers": [
            {
                "answer": "the original reference"
            },
            {
                "answer": "the object itself"
            },
            {
                "answer": "a reference to a copy"
            },
            {
                "answer": "a copy of the reference",
                "correct": "true"
            }
        ],
        "explanation": "You always get a copy of whatever is in the variable -- either a primitive or a reference. So for objects, you get a copy of the reference.",
        "id": "76",
        "question": "When you pass an object reference as an argument to a method call, what gets passed?"
    },
    {
        "answers": [
            {
                "answer": "No"
            },
            {
                "answer": "Yes",
                "correct": "true"
            }
        ],
        "explanation": "Private means \"private to the class\", NOT \"private to the object\". So two objects of the same class could access each other's private data. ",
        "id": "80",
        "question": "Can one object access a private variable of another object of the same class?"
    },
    {
        "answers": [
            {
                "answer": "declared public"
            },
            {
                "answer": "a subclass of y"
            },
            {
                "answer": "the same class as y"
            },
            {
                "answer": "In the same package as y",
                "correct": "true"
            }
        ],
        "explanation": "No access modifier really means \"default\" access which really means \"only to others in the package\". But you'll never see a keyword/modifier \"default\".",
        "id": "81",
        "question": "For object x to access a method of object y, when the method has no access modifier, object x MUST be an instance of a class which is:"
    },
    {
        "answers": [
            {
                "answer": "true"
            },
            {
                "answer": "false",
                "correct": "true"
            }
        ],
        "explanation": "Static variables CAN be marked final, which makes them essentialy constants, but they certainly don't have to be. Static just means \"one per class... not one per instance\"",
        "id": "82",
        "question": "static variables are implicitly final."
    },
    {
        "answers": [
            {
                "answer": "No"
            },
            {
                "answer": "Yes",
                "correct": "true"
            }
        ],
        "explanation": "Its legal to say anObject.aStaticMethod() but the preferred way is to use the class name - MyClass.aStaticMethod(), to make it obvious in your code that you're calling a static method.",
        "id": "83",
        "question": "Is it legal to access a static method using an instance of the class?"
    },
    {
        "answers": [
            {
                "answer": "Yes"
            },
            {
                "answer": "No",
                "correct": "true"
            }
        ],
        "explanation": "Within a static method, there is no 'this'! Since this refers to the current object -- the object whose method is executing -- 'this' makes no sense in a static method, since it doesn't belong to any object. ",
        "id": "84",
        "question": "Are static methods allowed to access instance variables using this.var?"
    },
    {
        "answers": [
            {
                "answer": "true"
            },
            {
                "answer": "false",
                "correct": "true"
            }
        ],
        "explanation": "Besides instance variables and inner classes, you can also define static code blocks. The compiler combines static blocks and static variable initialization into one big method which runs when the class is loaded.",
        "id": "85",
        "question": "The only things which can be defined inside a class and outside a method are instance variables and inner classes."
    },
    {
        "answers": [
            {
                "answer": "No"
            },
            {
                "answer": "Yes",
                "correct": "true"
            }
        ],
        "explanation": "So how do you make an object...? Obviously you'd need a less restrictive method (say, public) which can be called to create and return a new object. ",
        "id": "86",
        "question": "Can a constructor be declared private?"
    },
    {
        "answers": [
            {
                "answer": "Yes"
            },
            {
                "answer": "No",
                "correct": "true"
            }
        ],
        "explanation": "Since a constructor is used solely to create a new instance, and an abstract class can NEVER be instanced, it makes no sense.",
        "id": "87",
        "question": "Can a constructor be declared abstract?"
    },
    {
        "answers": [
            {
                "answer": "Yes"
            },
            {
                "answer": "No",
                "correct": "true"
            }
        ],
        "explanation": "Constructors are for creating new instance objects. Static methods are for non-instance code, so it makes no sense to have a static constructor.",
        "id": "88",
        "question": "Can a constructor be declared static?"
    },
    {
        "answers": [
            {
                "answer": "No"
            },
            {
                "answer": "Yes",
                "correct": "true"
            }
        ],
        "explanation": "The 2 is treated as an int literal, and since an int fits in a float, no explicit cast or 'f' is needed. If the literal was 2.0 (instead of 2), it would be treated as a double and would not compile.",
        "id": "89",
        "question": "Is this legal? float f = 2;"
    },
    {
        "answers": [
            {
                "answer": "No"
            },
            {
                "answer": "Yes",
                "correct": "true"
            }
        ],
        "explanation": "Any int can fit into a double-sized variable, so no cast is needed.",
        "id": "90",
        "question": "Can you automatically convert an int to a double?"
    },
    {
        "answers": [
            {
                "answer": "Yes"
            },
            {
                "answer": "No",
                "correct": "true"
            }
        ],
        "explanation": "Regardless of the double value, a double-sized variable is too big to fit in a float, so it can't be implicitly cast.",
        "id": "91",
        "question": "Can you pass a double to a method when the method's argument is a float?"
    },
    {
        "answers": [
            {
                "answer": "No"
            },
            {
                "answer": "Yes",
                "correct": "true"
            }
        ],
        "explanation": "Any object can always be referenced by a variable which is of a superclass type... because the child/subclass object is guaranteed to have the methods of the superclass.",
        "id": "92",
        "question": "Class Y is a subclass of class X. Will this compile? Y myY = new Y(); X myX = myY;"
    },
    {
        "answers": [
            {
                "answer": "true"
            },
            {
                "answer": "false",
                "correct": "true"
            }
        ],
        "explanation": "The break statements means \"break out of this structure completely!\". So the current iteration and any other remaining iterations of the loop will not run. Execution moves to the first statement below the loop.",
        "id": "93",
        "question": "Using a break in a for loop causes the loop to break out of the current iteration and jump to the next iteration of the loop."
    },
    {
        "answers": [
            {
                "answer": "Yes"
            },
            {
                "answer": "No",
                "correct": "true"
            }
        ],
        "explanation": "The only thing that can be an if (expression) is a boolean expression, and since in Java ints cannot be cast to booleans, if (anInteger) will not compile.",
        "id": "94",
        "question": "Is this legal? int i = 0; if (i) {}"
    },
    {
        "answers": [
            {
                "answer": "true"
            },
            {
                "answer": "false",
                "correct": "true"
            }
        ],
        "explanation": "The case argument must be either an int literal, or an int-compatible variable which is a constant (i.e. static final).",
        "id": "95",
        "question": "In a switch statement, the argument to the case label (case: argument) can be any variable which can fit within an int."
    },
    {
        "answers": [
            {
                "answer": "false"
            },
            {
                "answer": "true",
                "correct": "true"
            }
        ],
        "explanation": "Code executing as part of a case statement will just keep on running through other cases until/unless it reaches a break statement. This is called \"fall through\".",
        "id": "96",
        "question": "In a switch construct, once a matching case value is found, execution will continue through other case labels until it reaches a break statement."
    },
    {
        "answers": [
            {
                "answer": "true"
            },
            {
                "answer": "false",
                "correct": "true"
            }
        ],
        "explanation": "The default can be placed anywhere.",
        "id": "97",
        "question": "In a switch construct, the default statement must be placed after all the case statements."
    },
    {
        "answers": [
            {
                "answer": "java.lang.Error"
            },
            {
                "answer": "java.lang.Exception"
            },
            {
                "answer": "java.lang.Throwable",
                "correct": "true"
            }
        ],
        "explanation": "The Exception hierarchy begins at java.lang.Throwable.",
        "id": "98",
        "question": "All exceptions inherit from:"
    },
    {
        "answers": [
            {
                "answer": "true"
            },
            {
                "answer": "false",
                "correct": "true"
            }
        ],
        "explanation": "Method B does not have to declare the exception if it handles it (by providing an appropriate catch(theException), OR if the exception declared by A is a runtime exception.",
        "id": "99",
        "question": "If method A declares that it throws an exception and method B calls method A, then method B must ALWAYS declare the same exception."
    },
    {
        "answers": [
            {
                "answer": "Overloading"
            },
            {
                "answer": "Overriding",
                "correct": "true"
            }
        ],
        "explanation": "An overriding method must have the same name, return type, and arguments as the method in the superclass. It can't declare new or broader checked exceptions, and it also can't have more restrictive access.",
        "id": "100",
        "question": "Class A inherits from B. B includes a method with the same name, return type, and arguments as a method in A. This is an example of:"
    },
    {
        "answers": [
            {
                "answer": "true"
            },
            {
                "answer": "false",
                "correct": "true"
            }
        ],
        "explanation": "An overloaded method can change the return type, but return type alone is not enough -- it also must change the argument list.",
        "id": "101",
        "question": "A class can define two methods with the same name as long as the return types are different."
    },
    {
        "answers": [
            {
                "answer": "false"
            },
            {
                "answer": "true",
                "correct": "true"
            }
        ],
        "explanation": "ArithmeticException is a RuntimeException, so the rules about overriding methods not throwing new or broader exceptions does not apply.",
        "id": "102",
        "question": "An overriding method of a subclass can throw an Arithmetic Exception not thrown by the original (overriden) method."
    },
    {
        "answers": [
            {
                "answer": "true"
            },
            {
                "answer": "false",
                "correct": "true"
            }
        ],
        "explanation": "This would be true for overriding methods, but overloaded methods are free to throw new checked exceptions.",
        "id": "103",
        "question": "Overloaded methods must not throw new checked exceptions not thrown by the original method."
    },
    {
        "answers": [
            {
                "answer": "false"
            },
            {
                "answer": "true",
                "correct": "true"
            }
        ],
        "explanation": "An inner class has a special relationship and can see even private member data of the outer class. ",
        "id": "104",
        "question": "An inner class has free access to ALL member data of its enclosing (outer) class."
    },
    {
        "answers": [
            {
                "answer": "false"
            },
            {
                "answer": "true",
                "correct": "true"
            }
        ],
        "explanation": "A non-static inner class can ONLY exist as part of a relationship with an instance of its enclosing class.",
        "id": "105",
        "question": "It is not possible to have an instance of a non-static inner class before any instances of the outer class have been created."
    },
    {
        "answers": [
            {
                "answer": "false"
            },
            {
                "answer": "true",
                "correct": "true"
            }
        ],
        "explanation": "It may look strange, but that syntax is how you can create an instance of an inner class when you don't yet have an instance of the outer class. An inner class must ALWAYS be tied to an instance of the outer class.",
        "id": "106",
        "question": "This is a legal way to create an instance of an inner class: OuterClass.InnerClass x = new OuterClass().new InnerClass();"
    },
    {
        "answers": [
            {
                "answer": "false"
            },
            {
                "answer": "true",
                "correct": "true"
            }
        ],
        "explanation": "A static inner class is treated as a top-level nested class, and has no reference -- no special relationship -- to any instance of the enclosing class.",
        "id": "107",
        "question": "A static inner class (considered a top-level nested class) can NOT access non-static variables of the outer class."
    },
    {
        "answers": [
            {
                "answer": "doStuff() in A"
            },
            {
                "answer": "compiler error "
            },
            {
                "answer": "runtime error "
            },
            {
                "answer": "doStuff() in B",
                "correct": "true"
            }
        ],
        "explanation": "Java's polymorphism causes instance methods to be bound (chosen) at runtime, not during compilation. At runtime, the overriding method of the 'actual' object (which is a B) is dynamically chosen, even though the reference type is A.",
        "id": "108",
        "question": "Class B extends A. B overrides the doStuff() method inherited from A. Which methods gets called if you say: A myA = new B(); myA.doStuff();"
    },
    {
        "answers": [
            {
                "answer": "No"
            },
            {
                "answer": "Yes",
                "correct": "true"
            }
        ],
        "explanation": "You can have as many top-level classes in one source file as you like, but only one can be declared public and the source file name must match the public class name.",
        "id": "109",
        "question": "Are you allowed to have more than one top-level (non-inner) class definition per source file?"
    },
    {
        "answers": [
            {
                "answer": "Yes"
            },
            {
                "answer": "No",
                "correct": "true"
            }
        ],
        "explanation": "You don't have to have any public classes in your source files.",
        "id": "110",
        "question": "Are you required to have a public class in each source file?"
    },
    {
        "answers": [
            {
                "answer": "false"
            },
            {
                "answer": "true",
                "correct": "true"
            }
        ],
        "explanation": "No access modifier means \"default\" which means \"only to others in the package\".",
        "id": "116",
        "question": "Methods which have no access modifier can only be accessed by classes within the same package. TRUE or FALSE:"
    },
    {
        "answers": [
            {
                "answer": "true"
            },
            {
                "answer": "false",
                "correct": "true"
            }
        ],
        "explanation": "Protected means \"any subclass, regardless of package, can inherit these members -- methods or data\"",
        "id": "117",
        "question": "Methods which are marked protected can be accessed only by classes within the same package."
    },
    {
        "answers": [
            {
                "answer": "Yes"
            },
            {
                "answer": "No",
                "correct": "true"
            }
        ],
        "explanation": "Overriding methods can NOT be more restrictive than the original method. ",
        "id": "118",
        "question": "Can a public method be overriden by a protected method?"
    },
    {
        "answers": [
            {
                "answer": "true"
            },
            {
                "answer": "false",
                "correct": "true"
            }
        ],
        "explanation": "A final class is a class which can NOT be subclassed. Its the end-of-the-line in the inheritance tree.",
        "id": "119",
        "question": "Methods and variables can be declared as final, but a class can not be declared final."
    },
    {
        "answers": [
            {
                "answer": "Yes"
            },
            {
                "answer": "No",
                "correct": "true"
            }
        ],
        "explanation": "A final class means the end-of-the-line for the inhertance tree. No subclasses can be made from a final class, only instances.",
        "id": "120",
        "question": "Can a final class be subclassed?"
    },
    {
        "answers": [
            {
                "answer": "Yes"
            },
            {
                "answer": "No",
                "correct": "true"
            }
        ],
        "explanation": "final and abstract are opposites: a final class can NOT be subclassed, while an abstract class MUST be subclassed... so final abstract makes no sense.",
        "id": "121",
        "question": "Can you have a final abstract class?"
    },
    {
        "answers": [
            {
                "answer": "Yes"
            },
            {
                "answer": "No",
                "correct": "true"
            }
        ],
        "explanation": "Only methods and classes can be declared abstract.",
        "id": "122",
        "question": "Can a member variable be declared abstract?"
    },
    {
        "answers": [
            {
                "answer": "No"
            },
            {
                "answer": "Yes",
                "correct": "true"
            }
        ],
        "explanation": "An abstract method has no choice! It MUST be overridden.",
        "id": "123",
        "question": "Can an abstract method be overridden?"
    },
    {
        "answers": [
            {
                "answer": "Yes"
            },
            {
                "answer": "No",
                "correct": "true"
            }
        ],
        "explanation": "Methods can be native, not classes or variables.",
        "id": "124",
        "question": "Can a class be declared native?"
    },
    {
        "answers": [
            {
                "answer": "Yes"
            },
            {
                "answer": "No",
                "correct": "true"
            }
        ],
        "explanation": "Only methods can be native.",
        "id": "125",
        "question": "Can a member variable be declared native?"
    },
    {
        "answers": [
            {
                "answer": "Yes"
            },
            {
                "answer": "No",
                "correct": "true"
            }
        ],
        "explanation": "The transient modifier is used to keep variable data from being saved if an object is \"serialized\" (saved as an object ). Since methods don't change their state for an individual object, methods are never serialized, so transient is not needed for methods.",
        "id": "126",
        "question": "Can a method be declared transient?"
    },
    {
        "answers": [
            {
                "answer": "Yes"
            },
            {
                "answer": "No",
                "correct": "true"
            }
        ],
        "explanation": "Only data members can be declared as transient... meaning their value won't be saved when an object is \"serialized\" (saved).",
        "id": "127",
        "question": "Can a class be declared transient?"
    },
    {
        "answers": [
            {
                "answer": "Yes"
            },
            {
                "answer": "No",
                "correct": "true"
            }
        ],
        "explanation": "The word synchronized marks method code so that it can't be run by more than one thread at a time. ",
        "id": "128",
        "question": "Can a member variable be declared synchronized?"
    },
    {
        "answers": [
            {
                "answer": "Yes"
            },
            {
                "answer": "No",
                "correct": "true"
            }
        ],
        "explanation": "The keyword synchronized marks method code so that only one thread can access it at a time.",
        "id": "129",
        "question": "Can a class be declared synchronized?"
    },
    {
        "answers": [
            {
                "answer": "No"
            },
            {
                "answer": "Yes",
                "correct": "true"
            }
        ],
        "explanation": "The synchronized modifier means that only one thread at a time can run the synchronized code.",
        "id": "130",
        "question": "Can a method be declared synchronized?"
    },
    {
        "answers": [
            {
                "answer": "Won't compile without cast"
            },
            {
                "answer": "Runtime error"
            },
            {
                "answer": "Compiles and runs",
                "correct": "true"
            }
        ],
        "explanation": "The ++operator increments a as a byte, so there's no problem. You WOULD have a problem with a = a + 1; because the a + 1 would result in an int which would then have to be cast back to the byte variable a.",
        "id": "131",
        "question": "What happens when you compile this: byte a=2; a++; "
    },
    {
        "answers": [
            {
                "answer": "No"
            },
            {
                "answer": "Yes",
                "correct": "true"
            }
        ],
        "explanation": "It will compile, because the myX object might really have been a Y object all along (as far as the compiler knows), but at runtime it will fail.",
        "id": "132",
        "question": "Class Y is a subclass of class X. Will this compile? X myX = new X(); Y myY = (Y) myX;"
    },
    {
        "answers": [
            {
                "answer": "false"
            },
            {
                "answer": "true",
                "correct": "true"
            }
        ],
        "explanation": "The switch can obviously hold a variable, because that's what you're testing! But the variable cannot be anything except an int-compatible primitive.",
        "id": "133",
        "question": "In a switch statement, the argument to the switch ( ) can be a variable as long as it is compatible with an int."
    },
    {
        "answers": [
            {
                "answer": "true"
            },
            {
                "answer": "false",
                "correct": "true"
            }
        ],
        "explanation": "The default statement will only execute if no matching case is found, OR if there is \"fall through\" from a case statement executed above.",
        "id": "134",
        "question": "In a switch construct, the default statement will always execute."
    },
    {
        "answers": [
            {
                "answer": "false"
            },
            {
                "answer": "true",
                "correct": "true"
            }
        ],
        "explanation": "If there are no matching cases found, the default will run.",
        "id": "135",
        "question": "In a switch construct, the default statement will execute if no case values match the switch() argument."
    },
    {
        "answers": [
            {
                "answer": "true"
            },
            {
                "answer": "false",
                "correct": "true"
            }
        ],
        "explanation": "The catch blocks must be written in order from most specific to least (e.g. IOException comes above Exception) or the compiler will complain.",
        "id": "136",
        "question": "In a try/catch construct, the catch blocks may be written in any order and the most narrow/specific catch argument is chosen at runtime."
    },
    {
        "answers": [
            {
                "answer": "true"
            },
            {
                "answer": "false",
                "correct": "true"
            }
        ],
        "explanation": "The finally block will ALWAYS run... unless the try/catch calls System.exit().",
        "id": "137",
        "question": "A finally block will only be executed if the exception is not caught."
    },
    {
        "answers": [
            {
                "answer": "true"
            },
            {
                "answer": "false",
                "correct": "true"
            }
        ],
        "explanation": "System.exit() means stop the program now! Even a finally block can't stop that from happening.",
        "id": "140",
        "question": "If a try/catch construct calls System.exit(), the finally block will execute first."
    },
    {
        "answers": [
            {
                "answer": "false"
            },
            {
                "answer": "true",
                "correct": "true"
            }
        ],
        "explanation": "Since the protected modifier is less restrictive than default, an overriding method is allowed to make that change.",
        "id": "141",
        "question": "An overriding method can change the access modifier from default to protected."
    },
    {
        "answers": [
            {
                "answer": "this.theMethod();"
            },
            {
                "answer": "super.theMethod();",
                "correct": "true"
            }
        ],
        "explanation": "The super keyword is like a reference to the superclass.",
        "id": "142",
        "question": "To invoke an overriden method from the method which overrides it, use:"
    },
    {
        "answers": [
            {
                "answer": "false"
            },
            {
                "answer": "true",
                "correct": "true"
            }
        ],
        "explanation": "Constructors are different from methods in several ways, and inheritance is one of them. Subclasses do NOT get a constructor from the superclass.",
        "id": "143",
        "question": "Constructors are not inherited."
    },
    {
        "answers": [
            {
                "answer": "false"
            },
            {
                "answer": "true",
                "correct": "true"
            }
        ],
        "explanation": "One of the best uses of polymorphism in Java is to declare an array using an interface type, then add objects which can be from any class, as long as they implement the interface type of the array.",
        "id": "144",
        "question": "It is legal to declare an array with an interface as the type (instead of a class or primitive) -- example: PetInterface []p;"
    },
    {
        "answers": [
            {
                "answer": "Flyweight"
            },
            {
                "answer": "Singleton",
                "correct": "true"
            },
            {
                "answer": "Builder"
            },
            {
                "answer": "Factory"
            }
        ],
        "explanation": "",
        "id": "145",
        "question": "This design pattern ensures a class has only one instance and there is a global point of access to it."
    },
    {
        "answers": [
            {
                "answer": "Visitor"
            },
            {
                "answer": "Proxy"
            },
            {
                "answer": "Chain of Responsiblity"
            },
            {
                "answer": "Iterator",
                "correct": "true"
            }
        ],
        "explanation": "",
        "id": "146",
        "question": "Provides a way to access the elements of a collection sequentially without revealing the underlying implementation."
    },
    {
        "answers": [
            {
                "answer": "Strategy",
                "correct": "true"
            },
            {
                "answer": "Memento"
            },
            {
                "answer": "Chain of Responsiblity"
            },
            {
                "answer": "Adapter"
            }
        ],
        "explanation": "",
        "id": "147",
        "question": "Allows for an algorithm to be interchangeable with other algorithms."
    },
    {
        "answers": [
            {
                "answer": "Flyweight",
                "correct": "true"
            },
            {
                "answer": "Interpreter"
            },
            {
                "answer": "Bridge"
            },
            {
                "answer": "Command"
            }
        ],
        "explanation": "See lecture deck 27",
        "id": "148",
        "question": "What design pattern is this an example of? \"Do not create a new Integer(1), just return a reference to that instance from the existing pool of Integers -128..127\""
    },
    {
        "answers": [
            {
                "answer": "Decorator"
            },
            {
                "answer": "Composite",
                "correct": "true"
            },
            {
                "answer": "Interpreter"
            },
            {
                "answer": "Faade"
            }
        ],
        "explanation": "",
        "id": "149",
        "question": "Composes objects into tree structures to represent part-whole hierarchies."
    },
    {
        "answers": [
            {
                "answer": "Yes"
            },
            {
                "answer": "No",
                "correct": "true"
            }
        ],
        "explanation": "When a key exists, the value gets replaced (see slide #27)",
        "id": "150",
        "question": "hm is a Java HasMap:\\n\\nhm.put(\"a\", new BigInteger(\"123456\"));\\nhm.put(\"b\", new BigInteger(\"1234567\"));\\nhm.put(\"c\", new BigInteger(\"1234567\"));\\nhm.put(\"a\", new BigInteger(\"654321\"));\\nBigInteger aBigInt = hm.get(\"a\");\\nassertEquals(123456, aBigInt.intValue());\\n\\nDoes this assertion pass?"
    }
]
